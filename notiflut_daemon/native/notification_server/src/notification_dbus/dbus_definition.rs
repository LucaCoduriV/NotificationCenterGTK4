use crossroads::Crossroads;
// This code was autogenerated with `dbus-codegen-rust -r -g`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_crossroads as crossroads;

pub trait OrgFreedesktopNotifications {
    fn notify(
        &mut self,
        app_name: String,
        replaces_id: u32,
        app_icon: String,
        summary: String,
        body: String,
        actions: Vec<String>,
        hints: arg::PropMap,
        timeout: i32,
    ) -> Result<u32, dbus::MethodErr>;
    fn close_notification(&mut self, id: u32) -> Result<(), dbus::MethodErr>;
    fn get_capabilities(&mut self) -> Result<Vec<String>, dbus::MethodErr>;
    fn get_server_information(
        &mut self,
    ) -> Result<(String, String, String, String), dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgFreedesktopNotificationsNotificationClosed {
    pub id: u32,
    pub reason: u32,
}

impl arg::AppendAll for OrgFreedesktopNotificationsNotificationClosed {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.reason, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNotificationsNotificationClosed {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNotificationsNotificationClosed {
            id: i.read()?,
            reason: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNotificationsNotificationClosed {
    const NAME: &'static str = "NotificationClosed";
    const INTERFACE: &'static str = "org.freedesktop.Notifications";
}

#[derive(Debug)]
pub struct OrgFreedesktopNotificationsActionInvoked {
    pub id: u32,
    pub action_key: String,
}

impl arg::AppendAll for OrgFreedesktopNotificationsActionInvoked {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.action_key, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNotificationsActionInvoked {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNotificationsActionInvoked {
            id: i.read()?,
            action_key: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNotificationsActionInvoked {
    const NAME: &'static str = "ActionInvoked";
    const INTERFACE: &'static str = "org.freedesktop.Notifications";
}

pub fn register_org_freedesktop_notifications<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgFreedesktopNotifications + Send + 'static + Clone,
{
    cr.register("org.freedesktop.Notifications", |b| {
        b.signal::<(u32,u32,), _>("NotificationClosed", ("id","reason",));
        b.signal::<(u32,String,), _>("ActionInvoked", ("id","action_key",));
        b.method_with_cr_async("Notify", ("app_name","replaces_id","app_icon","summary","body","actions","hints","timeout",), ("",), 
            |mut ctx, cr: &mut Crossroads, (app_name,replaces_id,app_icon,summary,body,actions,hints,timeout,)| {
            let mut data = cr.data_mut::<T>(ctx.path()).unwrap().clone();
            async move {
                let result = data.notify(app_name,replaces_id,app_icon,summary,body,actions,hints,timeout,)
                    .map(|x| (x,));
                ctx.reply(result)
            }
        })
            .annotate("org.qtproject.QtDBus.QtTypeName.In6", "QVariantMap");
        b.method_with_cr_async("CloseNotification", ("id",), (), 
            |mut ctx, cr: &mut Crossroads, (id,)| {
            let mut data = cr.data_mut::<T>(ctx.path()).unwrap().clone();
            async move {
                let result = data.close_notification(id,);
                ctx.reply(result)
            }
        });
        b.method_with_cr_async("GetCapabilities", (), ("caps",), |mut ctx, cr: &mut Crossroads, ()| {
            let mut data = cr.data_mut::<T>(ctx.path()).unwrap().clone();
            async move {
                let result = data.get_capabilities()
                    .map(|x| (x,));
                ctx.reply(result)
            }
        });
        b.method_with_cr_async("GetServerInformation", (), ("name","vendor","version","spec_version",), 
            |mut ctx, cr: &mut Crossroads, ()| {
            let mut data = cr.data_mut::<T>(ctx.path()).unwrap().clone();
            async move {
                let result = data.get_server_information();
                ctx.reply(result)
            }
        });
    })
}
